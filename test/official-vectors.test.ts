/**
 * Official BLAKE3 Test Vectors
 *
 * Ported from https://github.com/zooko/potential-guacamole/blob/main/test_blake3.mjs
 * Tests against official BLAKE3 test vectors from:
 * https://github.com/BLAKE3-team/BLAKE3/blob/master/test_vectors/test_vectors.json
 *
 * Input data is generated by repeating the sequence 0, 1, 2, ..., 250, 0, 1, ...
 */

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { describe, it, expect } from "vitest";

import { hash, createKeyed, createDeriveKey, createHasher } from "../src/index.js";

// Load official test vectors
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const testVectorsPath = path.join(__dirname, "test_vectors.json");
const testVectors = JSON.parse(fs.readFileSync(testVectorsPath, "utf8")) as {
  key: string;
  context_string: string;
  cases: Array<{
    input_len: number;
    hash: string;
    keyed_hash: string;
    derive_key: string;
  }>;
};

// Generate input: repeating sequence 0, 1, 2, ..., 250, 0, 1, ...
function generateInput(length: number): Uint8Array {
  const buf = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    buf[i] = i % 251;
  }
  return buf;
}

// Convert Uint8Array to hex string
function toHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

// Convert ASCII string to Uint8Array (for key)
function asciiToBytes(str: string): Uint8Array {
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}

// Official test key and context from test vectors
const TEST_KEY = asciiToBytes(testVectors.key);
const TEST_CONTEXT = testVectors.context_string;

describe("Official BLAKE3 Test Vectors", () => {
  describe("Standard Hash (hash mode)", () => {
    for (const testCase of testVectors.cases) {
      it(`input_len=${testCase.input_len}`, () => {
        const input = generateInput(testCase.input_len);
        const digest = hash(input);
        // First 32 bytes = 64 hex chars
        const expected = testCase.hash.slice(0, 64);
        const actual = toHex(digest);
        expect(actual).toBe(expected);
      });
    }
  });

  describe("Keyed Hash (keyed_hash mode)", () => {
    for (const testCase of testVectors.cases) {
      it(`input_len=${testCase.input_len}`, () => {
        const input = generateInput(testCase.input_len);
        const hasher = createKeyed(TEST_KEY);
        hasher.update(input);
        const digest = hasher.finalize();
        // First 32 bytes = 64 hex chars
        const expected = testCase.keyed_hash.slice(0, 64);
        const actual = toHex(digest);
        expect(actual).toBe(expected);
      });
    }
  });

  describe("Key Derivation (derive_key mode)", () => {
    for (const testCase of testVectors.cases) {
      it(`input_len=${testCase.input_len}`, () => {
        const input = generateInput(testCase.input_len);
        const hasher = createDeriveKey(TEST_CONTEXT);
        hasher.update(input);
        const digest = hasher.finalize();
        // First 32 bytes = 64 hex chars
        const expected = testCase.derive_key.slice(0, 64);
        const actual = toHex(digest);
        expect(actual).toBe(expected);
      });
    }
  });

  describe("Extended Output (XOF mode)", () => {
    // Test that extended outputs match the full test vector hashes (131 bytes)
    for (const testCase of testVectors.cases) {
      // Only test a few sizes to keep test duration reasonable
      if (![0, 1, 64, 1024].includes(testCase.input_len)) continue;

      it(`extended output for input_len=${testCase.input_len}`, () => {
        const input = generateInput(testCase.input_len);
        // Use XOF reader to get 131 bytes (the full length of test vector hashes)
        const hasher = createHasher();
        hasher.update(input);
        const xof = hasher.finalizeXof();
        const digest = xof.read(131);
        const expected = testCase.hash;
        const actual = toHex(digest);
        expect(actual).toBe(expected);
      });
    }
  });
});
