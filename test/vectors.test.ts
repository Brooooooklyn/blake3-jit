/**
 * BLAKE3 Test Suite
 *
 * Tests against official BLAKE3 test vectors from:
 * https://github.com/BLAKE3-team/BLAKE3/blob/master/test_vectors/test_vectors.json
 *
 * Test vectors are generated by incrementing a counter from 0 to 250,
 * converting each byte to that counter value modulo 251.
 */

import { describe, it, expect } from "vitest";

import { hash, createKeyed, createDeriveKey, createHasher } from "../src/index.js";

// Helper to convert Uint8Array to hex string
function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

// Generate test input: bytes 0, 1, 2, ..., n-1 (mod 251)
function generateInput(length: number): Uint8Array {
  const input = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    input[i] = i % 251;
  }
  return input;
}

// Official BLAKE3 test key (32 bytes, ASCII "whats theEde Code for a series")
const TEST_KEY = new Uint8Array([
  0x77, 0x68, 0x61, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45, 0x64, 0x65, 0x20, 0x43, 0x6f,
  0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73,
]);

// Pad to 32 bytes
const PADDED_TEST_KEY = new Uint8Array(32);
PADDED_TEST_KEY.set(TEST_KEY);

// Known good vectors that we've verified
const VERIFIED_VECTORS = [
  {
    input_len: 0,
    hash: "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262",
  },
  {
    input_len: 1,
    hash: "2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213",
  },
  {
    input_len: 64,
    hash: "4eed7141ea4a5cd4b788606bd23f46e212af9cacebacdc7d1f4c6dc7f2511b98",
  },
  {
    input_len: 1024,
    hash: "42214739f095a406f3fc83deb889744ac00df831c10daa55189b5d121c855af7",
  },
];

describe("BLAKE3 Hash Function", () => {
  describe("Known Test Vectors", () => {
    for (const vec of VERIFIED_VECTORS) {
      it(`should hash ${vec.input_len} bytes correctly`, () => {
        const input = generateInput(vec.input_len);
        const result = hash(input);
        expect(bytesToHex(result)).toBe(vec.hash);
      });
    }
  });

  describe("Empty Input", () => {
    it("should hash empty input correctly", () => {
      const result = hash(new Uint8Array(0));
      expect(bytesToHex(result)).toBe(
        "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262",
      );
    });
  });

  describe("Single Byte", () => {
    it("should hash single byte correctly", () => {
      const result = hash(new Uint8Array([0]));
      expect(bytesToHex(result)).toBe(
        "2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213",
      );
    });
  });

  describe("Incremental Hashing", () => {
    it("should produce same result as one-shot", () => {
      const input = generateInput(1024);
      const oneShot = hash(input);

      const hasher = createHasher();
      hasher.update(input.subarray(0, 512));
      hasher.update(input.subarray(512));
      const incremental = hasher.finalize();

      expect(bytesToHex(incremental)).toBe(bytesToHex(oneShot));
    });

    it("should handle many small updates", () => {
      const input = generateInput(256);
      const oneShot = hash(input);

      const hasher = createHasher();
      for (let i = 0; i < input.length; i++) {
        hasher.update(input.subarray(i, i + 1));
      }
      const incremental = hasher.finalize();

      expect(bytesToHex(incremental)).toBe(bytesToHex(oneShot));
    });
  });

  describe("Variable Output Length", () => {
    it("should produce 32-byte output by default", () => {
      const result = hash(new Uint8Array([1, 2, 3]));
      expect(result.length).toBe(32);
    });

    it("should produce custom length output", () => {
      const result16 = hash(new Uint8Array([1, 2, 3]), 16);
      expect(result16.length).toBe(16);

      const result64 = hash(new Uint8Array([1, 2, 3]), 64);
      expect(result64.length).toBe(64);
    });

    it("should produce consistent prefix", () => {
      const input = new Uint8Array([1, 2, 3]);
      const result32 = hash(input, 32);
      const result64 = hash(input, 64);

      // First 32 bytes should match
      expect(bytesToHex(result64.subarray(0, 32))).toBe(bytesToHex(result32));
    });
  });

  describe("XOF Mode", () => {
    it("should produce arbitrary length output", () => {
      const hasher = createHasher();
      hasher.update(new Uint8Array([1, 2, 3]));
      const xof = hasher.finalizeXof();

      const chunk1 = xof.read(32);
      const chunk2 = xof.read(32);

      expect(chunk1.length).toBe(32);
      expect(chunk2.length).toBe(32);
      expect(bytesToHex(chunk1)).not.toBe(bytesToHex(chunk2));
    });
  });

  describe("Large Inputs", () => {
    it("should handle multi-chunk input", () => {
      // 2 chunks (2048 bytes)
      const input = generateInput(2048);
      const result = hash(input);
      expect(result.length).toBe(32);
    });

    it("should handle 1MB input", () => {
      const input = generateInput(1024 * 1024);
      const result = hash(input);
      expect(result.length).toBe(32);
    });
  });
});

describe("BLAKE3 Keyed Hash (MAC)", () => {
  const key = new Uint8Array(32);
  for (let i = 0; i < 32; i++) key[i] = i;

  it("should create keyed hasher", () => {
    const hasher = createKeyed(key);
    hasher.update(new Uint8Array([1, 2, 3]));
    const result = hasher.finalize();
    expect(result.length).toBe(32);
  });

  it("should produce different results with different keys", () => {
    const key1 = new Uint8Array(32).fill(1);
    const key2 = new Uint8Array(32).fill(2);
    const input = new Uint8Array([1, 2, 3]);

    const result1 = createKeyed(key1).update(input).finalize();
    const result2 = createKeyed(key2).update(input).finalize();

    expect(bytesToHex(result1)).not.toBe(bytesToHex(result2));
  });

  it("should require 32-byte key", () => {
    expect(() => createKeyed(new Uint8Array(16))).toThrow();
    expect(() => createKeyed(new Uint8Array(64))).toThrow();
  });
});

describe("BLAKE3 Key Derivation", () => {
  it("should derive key from context", () => {
    const hasher = createDeriveKey("my-app v1 encryption key");
    hasher.update(new Uint8Array([1, 2, 3, 4]));
    const result = hasher.finalize(32);
    expect(result.length).toBe(32);
  });

  it("should produce different keys for different contexts", () => {
    const input = new Uint8Array([1, 2, 3, 4]);

    const key1 = createDeriveKey("context 1").update(input).finalize();
    const key2 = createDeriveKey("context 2").update(input).finalize();

    expect(bytesToHex(key1)).not.toBe(bytesToHex(key2));
  });

  it("should produce different keys for different inputs", () => {
    const context = "my context";

    const key1 = createDeriveKey(context)
      .update(new Uint8Array([1]))
      .finalize();
    const key2 = createDeriveKey(context)
      .update(new Uint8Array([2]))
      .finalize();

    expect(bytesToHex(key1)).not.toBe(bytesToHex(key2));
  });
});

describe("Consistency Tests", () => {
  it("should produce consistent results", () => {
    const input = new Uint8Array([1, 2, 3, 4, 5]);
    const result1 = hash(input);
    const result2 = hash(input);
    expect(bytesToHex(result1)).toBe(bytesToHex(result2));
  });

  it("should handle Uint8Array from different buffer", () => {
    const buffer = new ArrayBuffer(100);
    const view = new Uint8Array(buffer, 10, 50);
    for (let i = 0; i < 50; i++) view[i] = i;

    const result = hash(view);
    expect(result.length).toBe(32);
  });
});
